// Generated automatically by nearley, version 2.19.0
// http://github.com/Hardmath123/nearley
(function () {
function id(x) { return x[0]; }

	const moo = require('moo')
	const lexer = moo.compile({
		
		keywords: /(?:if|then|else|do|unless|where|match|when|case|of|otherwise|let|in|not|and|or|import|export|from|to|module|as|type|instance)\b/,
		true:   /(?:true|on|active|yes|enabled)\b/,
		false:  /(?:false|off|inactive|no|disabled)\b/,
		rarrow: "->",
		larror: "<-",
		rchevron: ">-",
		lchevron: "-<",
		binaryOp: ["+", "-", "*", "/", "<", ">", "<=", ">=", "==", "&&", "||", "|>", "<|", ">>", "<<", "<>"],
		unaryOp: ["!", "++", "--", "?"],
		assignment: "=",
		delimiter: ["{", "}", "[", "]", "(", ")"],				
		comma: ",",
		colon: ":",
		union: "|",	
		ws: /[ \t]+/,
		nl:  { match: /\n+/, lineBreaks: true },
		dot: /\./,		
		identifier: /[a-zA-Z_]\w*/,
		digits:  /[0-9]+/,
		string:  /'(?:\\["\\]|[^\n"\\])*'|"(?:\\["\\]|[^\n"\\])*"/

	});
var grammar = {
    Lexer: lexer,
    ParserRules: [
    {"name": "script$ebnf$1", "symbols": []},
    {"name": "script$ebnf$1", "symbols": ["script$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "script$ebnf$2", "symbols": []},
    {"name": "script$ebnf$2$subexpression$1", "symbols": ["wrapped"]},
    {"name": "script$ebnf$2", "symbols": ["script$ebnf$2", "script$ebnf$2$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "script$ebnf$3", "symbols": ["__"], "postprocess": id},
    {"name": "script$ebnf$3", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "script", "symbols": ["script$ebnf$1", "imports", "expression", "script$ebnf$2", "script$ebnf$3"], "postprocess":  ([,[imports], head, tail]) => {
        	const arr = tail ? tail.map(([ expr]) => expr) : []
        	return { type: "script", val: [ {type: 'expression', value: head }, ...arr] }
        } },
    {"name": "wrapped$ebnf$1", "symbols": []},
    {"name": "wrapped$ebnf$1", "symbols": ["wrapped$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "wrapped", "symbols": [(lexer.has("nl") ? {type: "nl"} : nl), "wrapped$ebnf$1", "expression"], "postprocess": ([,,e]) => ({type: 'expression', value: e })},
    {"name": "imports$ebnf$1", "symbols": []},
    {"name": "imports$ebnf$1$subexpression$1$subexpression$1$ebnf$1", "symbols": []},
    {"name": "imports$ebnf$1$subexpression$1$subexpression$1$ebnf$1", "symbols": ["imports$ebnf$1$subexpression$1$subexpression$1$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "imports$ebnf$1$subexpression$1$subexpression$1", "symbols": [(lexer.has("nl") ? {type: "nl"} : nl), "imports$ebnf$1$subexpression$1$subexpression$1$ebnf$1"]},
    {"name": "imports$ebnf$1$subexpression$1", "symbols": ["import", "imports$ebnf$1$subexpression$1$subexpression$1"]},
    {"name": "imports$ebnf$1", "symbols": ["imports$ebnf$1", "imports$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "imports", "symbols": ["imports$ebnf$1"]},
    {"name": "import$subexpression$1$ebnf$1", "symbols": []},
    {"name": "import$subexpression$1$ebnf$1", "symbols": ["import$subexpression$1$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "import$subexpression$1", "symbols": ["__", "import$subexpression$1$ebnf$1"]},
    {"name": "import$subexpression$2$ebnf$1", "symbols": []},
    {"name": "import$subexpression$2$ebnf$1", "symbols": ["import$subexpression$2$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "import$subexpression$2", "symbols": ["__", "import$subexpression$2$ebnf$1"]},
    {"name": "import$subexpression$3$ebnf$1", "symbols": []},
    {"name": "import$subexpression$3$ebnf$1", "symbols": ["import$subexpression$3$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "import$subexpression$3", "symbols": ["__", "import$subexpression$3$ebnf$1"]},
    {"name": "import", "symbols": [{"literal":"import"}, "import$subexpression$1", "identifier", "import$subexpression$2", {"literal":"from"}, "import$subexpression$3", "string"], "postprocess": ([,, id,,,, file]) => ({ type: "import", id, file })},
    {"name": "export$subexpression$1$ebnf$1", "symbols": []},
    {"name": "export$subexpression$1$ebnf$1", "symbols": ["export$subexpression$1$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "export$subexpression$1", "symbols": ["__", "export$subexpression$1$ebnf$1"]},
    {"name": "export", "symbols": [{"literal":"export"}, "export$subexpression$1", "expression"], "postprocess": ([,, expr]) => ({ type: "export", value: expr })},
    {"name": "expression", "symbols": ["identifier"], "postprocess": id},
    {"name": "expression", "symbols": ["literal"], "postprocess": ([literal]) => ({type: "literal", value: literal })},
    {"name": "expression", "symbols": ["assignment"], "postprocess": id},
    {"name": "expression", "symbols": ["parenthesis"], "postprocess": id},
    {"name": "expression", "symbols": ["property"], "postprocess": id},
    {"name": "expression", "symbols": ["operation"], "postprocess": id},
    {"name": "expression", "symbols": ["ifThenElse"], "postprocess": ([expr]) => ({type: "control-flow", value: expr })},
    {"name": "expression", "symbols": ["match"], "postprocess": ([expr]) => ({type: "control-flow", value: expr })},
    {"name": "expression", "symbols": ["function"], "postprocess": id},
    {"name": "expression", "symbols": ["functionApplication"], "postprocess": id},
    {"name": "expression$subexpression$1", "symbols": [(lexer.has("binaryOp") ? {type: "binaryOp"} : binaryOp)]},
    {"name": "expression$subexpression$1", "symbols": [(lexer.has("unaryOp") ? {type: "unaryOp"} : unaryOp)]},
    {"name": "expression", "symbols": ["expression$subexpression$1"], "postprocess": ([[op]]) => ({ type: "operator-function", operator: { type: op.type, value: op.value } })},
    {"name": "parenthesis", "symbols": [{"literal":"("}, "_", "expression", "_", {"literal":")"}], "postprocess": ([,, expr,,]) => ({type: "parenthesis", value: expr })},
    {"name": "identifier", "symbols": [(lexer.has("identifier") ? {type: "identifier"} : identifier)], "postprocess": ([{ type, value }]) => ({type, value})},
    {"name": "literal", "symbols": ["number"], "postprocess": ([num]) => ({type: 'number', value: num})},
    {"name": "literal", "symbols": ["string"], "postprocess": ([str]) => ({type: 'string', value: str})},
    {"name": "literal", "symbols": ["boolean"], "postprocess": ([boolean]) => ({type: "boolean", value: boolean})},
    {"name": "literal", "symbols": ["tuple"], "postprocess": ([tuple]) => ({type: 'tuple', value: tuple})},
    {"name": "literal", "symbols": ["list"], "postprocess": ([list]) => ({type: 'list', value: list})},
    {"name": "literal", "symbols": ["record"], "postprocess": ([record]) => ({type: 'record', value: record})},
    {"name": "literal", "symbols": ["graph"], "postprocess": id},
    {"name": "literal", "symbols": ["graphPattern"], "postprocess": id},
    {"name": "assignment", "symbols": ["identifier", "_", {"literal":"="}, "_", "expression"], "postprocess": ([id,, equals,, expression]) => ({ type: "assignment", id, value: expression })},
    {"name": "property$subexpression$1", "symbols": ["record"]},
    {"name": "property$subexpression$1", "symbols": ["identifier"]},
    {"name": "property$subexpression$1", "symbols": ["parenthesis"]},
    {"name": "property$subexpression$1", "symbols": ["property"]},
    {"name": "property", "symbols": ["property$subexpression$1", (lexer.has("dot") ? {type: "dot"} : dot), "identifier"], "postprocess": ([[context],, value]) => ({type: "property", context, value })},
    {"name": "operation", "symbols": ["algebraic"], "postprocess": ([math]) => ({type: 'math', ...math})},
    {"name": "operation", "symbols": ["logic"], "postprocess": ([logic]) => ({type: 'logical', ...logic})},
    {"name": "operation", "symbols": ["condition"], "postprocess": ([condition]) => ({type: 'conditional', ...condition})},
    {"name": "operation", "symbols": ["composition"], "postprocess": ([composition]) => ({type: 'composition', ...composition})},
    {"name": "operation", "symbols": ["concatenation"], "postprocess": ([concatenation]) => ({type: 'concatenation', ...concatenation})},
    {"name": "operation", "symbols": ["graphQuery"], "postprocess": ([query]) => ({type: 'graph-query', ...query})},
    {"name": "operation", "symbols": ["graphMutation"], "postprocess": ([mutation]) => ({type: 'graph-mutation', ...mutation})},
    {"name": "ifThenElse$ebnf$1", "symbols": ["__"]},
    {"name": "ifThenElse$ebnf$1", "symbols": ["ifThenElse$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "ifThenElse$ebnf$2", "symbols": ["__"]},
    {"name": "ifThenElse$ebnf$2", "symbols": ["ifThenElse$ebnf$2", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "ifThenElse", "symbols": [{"literal":"if"}, "__", "expression", "ifThenElse$ebnf$1", {"literal":"then"}, "__", "expression", "ifThenElse$ebnf$2", {"literal":"else"}, "__", "expression"], "postprocess": ([ ,,condition,, ,,truthy,, ,,falsy]) => ({ type: "if-then-else", condition, truthy, falsy })},
    {"name": "match$ebnf$1$subexpression$1$ebnf$1", "symbols": ["__"]},
    {"name": "match$ebnf$1$subexpression$1$ebnf$1", "symbols": ["match$ebnf$1$subexpression$1$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "match$ebnf$1$subexpression$1$ebnf$2", "symbols": ["__"]},
    {"name": "match$ebnf$1$subexpression$1$ebnf$2", "symbols": ["match$ebnf$1$subexpression$1$ebnf$2", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "match$ebnf$1$subexpression$1", "symbols": ["match$ebnf$1$subexpression$1$ebnf$1", (lexer.has("union") ? {type: "union"} : union), "match$ebnf$1$subexpression$1$ebnf$2", "expression", "_", {"literal":"->"}, "_", "expression"]},
    {"name": "match$ebnf$1", "symbols": ["match$ebnf$1$subexpression$1"]},
    {"name": "match$ebnf$1$subexpression$2$ebnf$1", "symbols": ["__"]},
    {"name": "match$ebnf$1$subexpression$2$ebnf$1", "symbols": ["match$ebnf$1$subexpression$2$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "match$ebnf$1$subexpression$2$ebnf$2", "symbols": ["__"]},
    {"name": "match$ebnf$1$subexpression$2$ebnf$2", "symbols": ["match$ebnf$1$subexpression$2$ebnf$2", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "match$ebnf$1$subexpression$2", "symbols": ["match$ebnf$1$subexpression$2$ebnf$1", (lexer.has("union") ? {type: "union"} : union), "match$ebnf$1$subexpression$2$ebnf$2", "expression", "_", {"literal":"->"}, "_", "expression"]},
    {"name": "match$ebnf$1", "symbols": ["match$ebnf$1", "match$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "match$ebnf$2$subexpression$1$ebnf$1", "symbols": ["__"]},
    {"name": "match$ebnf$2$subexpression$1$ebnf$1", "symbols": ["match$ebnf$2$subexpression$1$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "match$ebnf$2$subexpression$1$ebnf$2", "symbols": ["__"]},
    {"name": "match$ebnf$2$subexpression$1$ebnf$2", "symbols": ["match$ebnf$2$subexpression$1$ebnf$2", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "match$ebnf$2$subexpression$1", "symbols": ["match$ebnf$2$subexpression$1$ebnf$1", (lexer.has("union") ? {type: "union"} : union), "match$ebnf$2$subexpression$1$ebnf$2", {"literal":"otherwise"}, "_", {"literal":"->"}, "_", "expression"]},
    {"name": "match$ebnf$2", "symbols": ["match$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "match$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "match", "symbols": [{"literal":"match"}, "__", "expression", "match$ebnf$1", "match$ebnf$2"], "postprocess":  ([,, expression, patterns, otherwise]) => ({ 
        	type: "match", 
        	expression,
        	patterns: patterns.map(([,,, evaluation,,,, value]) => ({ evaluation, value })), 
        	otherwise: otherwise ? otherwise[otherwise.length -1] : null 
        }) },
    {"name": "logic$subexpression$1", "symbols": ["identifier"]},
    {"name": "logic$subexpression$1", "symbols": ["boolean"]},
    {"name": "logic$subexpression$1", "symbols": ["property"]},
    {"name": "logic$subexpression$1", "symbols": ["functionApplication"]},
    {"name": "logic$subexpression$1", "symbols": ["parenthesis"]},
    {"name": "logic$subexpression$2", "symbols": [{"literal":"||"}]},
    {"name": "logic$subexpression$2", "symbols": [{"literal":"&&"}]},
    {"name": "logic", "symbols": ["logic$subexpression$1", "_", "logic$subexpression$2", "_", "expression"], "postprocess": ([[left],, [op],, right]) => ({operator: op.value, left, right})},
    {"name": "logic", "symbols": [{"literal":"!"}, "expression"], "postprocess": ([op, expression]) => ({operator: op.value, expression})},
    {"name": "algebraic$subexpression$1", "symbols": ["identifier"]},
    {"name": "algebraic$subexpression$1", "symbols": ["number"]},
    {"name": "algebraic$subexpression$1", "symbols": ["property"]},
    {"name": "algebraic$subexpression$1", "symbols": ["functionApplication"]},
    {"name": "algebraic$subexpression$1", "symbols": ["parenthesis"]},
    {"name": "algebraic$subexpression$2", "symbols": [{"literal":"+"}]},
    {"name": "algebraic$subexpression$2", "symbols": [{"literal":"-"}]},
    {"name": "algebraic$subexpression$2", "symbols": [{"literal":"*"}]},
    {"name": "algebraic$subexpression$2", "symbols": [{"literal":"/"}]},
    {"name": "algebraic", "symbols": ["algebraic$subexpression$1", "_", "algebraic$subexpression$2", "_", "expression"], "postprocess": ([[left],, [op],, right]) => ({operator: op.value, left, right})},
    {"name": "condition$subexpression$1", "symbols": ["identifier"]},
    {"name": "condition$subexpression$1", "symbols": ["literal"]},
    {"name": "condition$subexpression$1", "symbols": ["property"]},
    {"name": "condition$subexpression$1", "symbols": ["functionApplication"]},
    {"name": "condition$subexpression$1", "symbols": ["parenthesis"]},
    {"name": "condition$subexpression$2", "symbols": [{"literal":"<"}]},
    {"name": "condition$subexpression$2", "symbols": [{"literal":">"}]},
    {"name": "condition$subexpression$2", "symbols": [{"literal":"<="}]},
    {"name": "condition$subexpression$2", "symbols": [{"literal":">="}]},
    {"name": "condition$subexpression$2", "symbols": [{"literal":"=="}]},
    {"name": "condition", "symbols": ["condition$subexpression$1", "_", "condition$subexpression$2", "_", "expression"], "postprocess": ([[left],, [op],, right]) => ({operator: op.value, left, right})},
    {"name": "composition$subexpression$1", "symbols": ["identifier"]},
    {"name": "composition$subexpression$1", "symbols": ["function"]},
    {"name": "composition$subexpression$1", "symbols": ["property"]},
    {"name": "composition$subexpression$1", "symbols": ["functionApplication"]},
    {"name": "composition$subexpression$1", "symbols": ["parenthesis"]},
    {"name": "composition$subexpression$2", "symbols": [{"literal":"<<"}]},
    {"name": "composition$subexpression$2", "symbols": [{"literal":">>"}]},
    {"name": "composition", "symbols": ["composition$subexpression$1", "_", "composition$subexpression$2", "_", "expression"], "postprocess": ([[left],, [op],, right]) => ({operator: op.value, left, right})},
    {"name": "concatenation$subexpression$1", "symbols": ["identifier"]},
    {"name": "concatenation$subexpression$1", "symbols": ["literal"]},
    {"name": "concatenation$subexpression$1", "symbols": ["property"]},
    {"name": "concatenation$subexpression$1", "symbols": ["functionApplication"]},
    {"name": "concatenation$subexpression$1", "symbols": ["parenthesis"]},
    {"name": "concatenation", "symbols": ["concatenation$subexpression$1", "_", {"literal":"<>"}, "_", "expression"], "postprocess": ([[left],, op,, right]) => ({operator: op.value, left, right})},
    {"name": "graphQuery$subexpression$1", "symbols": ["identifier"]},
    {"name": "graphQuery$subexpression$1", "symbols": ["graph"]},
    {"name": "graphQuery$subexpression$1", "symbols": ["parenthesis"]},
    {"name": "graphQuery$subexpression$2", "symbols": ["identifier"]},
    {"name": "graphQuery$subexpression$2", "symbols": ["graphPattern"]},
    {"name": "graphQuery$subexpression$2", "symbols": ["parenthesis"]},
    {"name": "graphQuery", "symbols": ["graphQuery$subexpression$1", "_", {"literal":"|-"}, "_", "graphQuery$subexpression$2"], "postprocess": ([[left],, op,, [right]]) => ({operator: op.value, left, right})},
    {"name": "graphMutation$subexpression$1", "symbols": ["identifier"]},
    {"name": "graphMutation$subexpression$1", "symbols": ["graph"]},
    {"name": "graphMutation$subexpression$1", "symbols": ["parenthesis"]},
    {"name": "graphMutation$subexpression$2", "symbols": ["identifier"]},
    {"name": "graphMutation$subexpression$2", "symbols": ["graphPattern"]},
    {"name": "graphMutation$subexpression$2", "symbols": ["parenthesis"]},
    {"name": "graphMutation", "symbols": ["graphMutation$subexpression$1", "_", {"literal":"-|"}, "_", "graphMutation$subexpression$2"], "postprocess": ([[left],, op,, [right]]) => ({operator: op.value, left, right})},
    {"name": "arguments$ebnf$1", "symbols": []},
    {"name": "arguments$ebnf$1$subexpression$1$ebnf$1", "symbols": []},
    {"name": "arguments$ebnf$1$subexpression$1$ebnf$1", "symbols": ["arguments$ebnf$1$subexpression$1$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "arguments$ebnf$1$subexpression$1", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws), "arguments$ebnf$1$subexpression$1$ebnf$1", "identifier"]},
    {"name": "arguments$ebnf$1", "symbols": ["arguments$ebnf$1", "arguments$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "arguments", "symbols": ["identifier", "arguments$ebnf$1"], "postprocess": ([arg, args]) => [arg.value, ...args.map(([,, a]) => a.value)]},
    {"name": "parameters$ebnf$1$subexpression$1$ebnf$1", "symbols": []},
    {"name": "parameters$ebnf$1$subexpression$1$ebnf$1", "symbols": ["parameters$ebnf$1$subexpression$1$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "parameters$ebnf$1$subexpression$1", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws), "parameters$ebnf$1$subexpression$1$ebnf$1", "parameter"]},
    {"name": "parameters$ebnf$1", "symbols": ["parameters$ebnf$1$subexpression$1"]},
    {"name": "parameters$ebnf$1$subexpression$2$ebnf$1", "symbols": []},
    {"name": "parameters$ebnf$1$subexpression$2$ebnf$1", "symbols": ["parameters$ebnf$1$subexpression$2$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "parameters$ebnf$1$subexpression$2", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws), "parameters$ebnf$1$subexpression$2$ebnf$1", "parameter"]},
    {"name": "parameters$ebnf$1", "symbols": ["parameters$ebnf$1", "parameters$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "parameters", "symbols": ["parameters$ebnf$1"], "postprocess": ([params]) => params.map(([,, p]) => p)},
    {"name": "parameter", "symbols": ["literal"], "postprocess": id},
    {"name": "parameter", "symbols": ["identifier"], "postprocess": id},
    {"name": "parameter", "symbols": ["parenthesis"], "postprocess": id},
    {"name": "function$subexpression$1$ebnf$1", "symbols": []},
    {"name": "function$subexpression$1$ebnf$1", "symbols": ["function$subexpression$1$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "function$subexpression$1", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws), "function$subexpression$1$ebnf$1"]},
    {"name": "function$subexpression$2$ebnf$1", "symbols": []},
    {"name": "function$subexpression$2$ebnf$1", "symbols": ["function$subexpression$2$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "function$subexpression$2", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws), "function$subexpression$2$ebnf$1"]},
    {"name": "function", "symbols": ["arguments", "function$subexpression$1", {"literal":"->"}, "function$subexpression$2", "expression"], "postprocess": ([args,, arrow,, expression]) => ({ type: "function", args, value: expression })},
    {"name": "functionApplication$ebnf$1", "symbols": [{"literal":"<|"}], "postprocess": id},
    {"name": "functionApplication$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "functionApplication", "symbols": ["identifier", "_", "functionApplication$ebnf$1", "parameters"], "postprocess": ([id,, pipeline, params]) => ({ type: "function-application", id, params })},
    {"name": "functionApplication", "symbols": ["parameters", {"literal":"|>"}, "identifier"], "postprocess": ([params, pipeline, id]) => ({ type: "function-application", id, params })},
    {"name": "tuple$ebnf$1$subexpression$1", "symbols": [{"literal":","}, "_", "expression", "_"]},
    {"name": "tuple$ebnf$1", "symbols": ["tuple$ebnf$1$subexpression$1"]},
    {"name": "tuple$ebnf$1$subexpression$2", "symbols": [{"literal":","}, "_", "expression", "_"]},
    {"name": "tuple$ebnf$1", "symbols": ["tuple$ebnf$1", "tuple$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "tuple", "symbols": [{"literal":"("}, "_", "expression", "_", "tuple$ebnf$1", {"literal":")"}], "postprocess": ([,, expr,, rest,]) => [expr, ...rest.map(([,, xpr,]) => xpr)]},
    {"name": "list", "symbols": [{"literal":"["}, "_", {"literal":"]"}], "postprocess": () => []},
    {"name": "list$ebnf$1", "symbols": []},
    {"name": "list$ebnf$1$subexpression$1", "symbols": [{"literal":","}, "_", "expression", "_"]},
    {"name": "list$ebnf$1", "symbols": ["list$ebnf$1", "list$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "list", "symbols": [{"literal":"["}, "_", "expression", "_", "list$ebnf$1", {"literal":"]"}], "postprocess": ([,, expr,, rest,]) => [expr, ...rest.map(([,, xpr,]) => xpr)]},
    {"name": "record", "symbols": [{"literal":"{"}, "_", {"literal":"}"}], "postprocess": () => ({ })},
    {"name": "record$ebnf$1", "symbols": []},
    {"name": "record$ebnf$1$subexpression$1", "symbols": [{"literal":","}, "_", "key", "_", {"literal":":"}, "_", "expression", "_"]},
    {"name": "record$ebnf$1", "symbols": ["record$ebnf$1", "record$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "record", "symbols": [{"literal":"{"}, "_", "key", "_", {"literal":":"}, "_", "expression", "_", "record$ebnf$1", {"literal":"}"}], "postprocess": ([,, key,, colon,, value,, rest,]) => [{ key, value }, ...rest.map(([,,k,,,,v,]) => ({ key: k, value: v })) ]},
    {"name": "key", "symbols": ["identifier"], "postprocess": ([id]) => id.value},
    {"name": "graph$ebnf$1", "symbols": []},
    {"name": "graph$ebnf$1", "symbols": ["graph$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "graph", "symbols": [(lexer.has("lchevron") ? {type: "lchevron"} : lchevron), "graph$ebnf$1", (lexer.has("rchevron") ? {type: "rchevron"} : rchevron)], "postprocess": _  => ({ type: 'graph', value: [] })},
    {"name": "graph$ebnf$2", "symbols": []},
    {"name": "graph$ebnf$2", "symbols": ["graph$ebnf$2", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "graph$subexpression$1", "symbols": ["graphPattern"]},
    {"name": "graph$subexpression$1", "symbols": ["identifier"]},
    {"name": "graph$subexpression$1", "symbols": ["parenthesis"]},
    {"name": "graph$ebnf$3", "symbols": []},
    {"name": "graph$ebnf$3", "symbols": ["graph$ebnf$3", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "graph$ebnf$4", "symbols": []},
    {"name": "graph$ebnf$4$subexpression$1$ebnf$1", "symbols": []},
    {"name": "graph$ebnf$4$subexpression$1$ebnf$1", "symbols": ["graph$ebnf$4$subexpression$1$ebnf$1", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "graph$ebnf$4$subexpression$1$subexpression$1", "symbols": ["graphPattern"]},
    {"name": "graph$ebnf$4$subexpression$1$subexpression$1", "symbols": ["identifier"]},
    {"name": "graph$ebnf$4$subexpression$1$subexpression$1", "symbols": ["parenthesis"]},
    {"name": "graph$ebnf$4$subexpression$1$ebnf$2", "symbols": []},
    {"name": "graph$ebnf$4$subexpression$1$ebnf$2", "symbols": ["graph$ebnf$4$subexpression$1$ebnf$2", "__"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "graph$ebnf$4$subexpression$1", "symbols": [{"literal":","}, "graph$ebnf$4$subexpression$1$ebnf$1", "graph$ebnf$4$subexpression$1$subexpression$1", "graph$ebnf$4$subexpression$1$ebnf$2"]},
    {"name": "graph$ebnf$4", "symbols": ["graph$ebnf$4", "graph$ebnf$4$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "graph", "symbols": [(lexer.has("lchevron") ? {type: "lchevron"} : lchevron), "graph$ebnf$2", "graph$subexpression$1", "graph$ebnf$3", "graph$ebnf$4", (lexer.has("rchevron") ? {type: "rchevron"} : rchevron)], "postprocess": ([,, [pat],, rest,]) => ({ type: 'graph', value: [pat, ...rest.map(([,, [p],]) => p)] })},
    {"name": "gNode$ebnf$1", "symbols": []},
    {"name": "gNode$ebnf$1$subexpression$1", "symbols": [{"literal":":"}, "identifier"]},
    {"name": "gNode$ebnf$1", "symbols": ["gNode$ebnf$1", "gNode$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "gNode", "symbols": [{"literal":"("}, "_", "gNode$ebnf$1", {"literal":")"}], "postprocess": ([,, labels]) => ({ type: "graph-node", value: { type: "any" }, labels: labels.map(([, label]) => label.value) })},
    {"name": "gNode$ebnf$2", "symbols": []},
    {"name": "gNode$ebnf$2$subexpression$1", "symbols": [{"literal":":"}, "identifier"]},
    {"name": "gNode$ebnf$2", "symbols": ["gNode$ebnf$2", "gNode$ebnf$2$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "gNode", "symbols": [{"literal":"("}, "identifier", "_", "gNode$ebnf$2", {"literal":")"}], "postprocess": ([, id ,, labels, ]) => ({ type: "graph-node", value: id, labels: labels.map(([, label]) => label.value) })},
    {"name": "gRelId$ebnf$1", "symbols": []},
    {"name": "gRelId$ebnf$1$subexpression$1", "symbols": [{"literal":":"}, "identifier"]},
    {"name": "gRelId$ebnf$1", "symbols": ["gRelId$ebnf$1", "gRelId$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "gRelId", "symbols": [{"literal":"["}, "_", "gRelId$ebnf$1", {"literal":"]"}], "postprocess": ([,, labels]) => ({ type: "any", labels: labels.map(([, label]) => label.value) })},
    {"name": "gRelId$ebnf$2", "symbols": []},
    {"name": "gRelId$ebnf$2$subexpression$1", "symbols": [{"literal":":"}, "identifier"]},
    {"name": "gRelId$ebnf$2", "symbols": ["gRelId$ebnf$2", "gRelId$ebnf$2$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "gRelId", "symbols": [{"literal":"["}, "identifier", "_", "gRelId$ebnf$2", {"literal":"]"}], "postprocess": ([, id ,, labels, ]) => ({ ...id, labels: labels.map(([, label]) => label.value) })},
    {"name": "gRel$ebnf$1", "symbols": ["gRelId"], "postprocess": id},
    {"name": "gRel$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "gRel", "symbols": [{"literal":"-"}, "gRel$ebnf$1", {"literal":"-"}], "postprocess": ([, { type, value, labels },]) => ({ type: "graph-edge", direction: "bilateral", value: { type, value}, labels })},
    {"name": "gRel$ebnf$2", "symbols": ["gRelId"], "postprocess": id},
    {"name": "gRel$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "gRel", "symbols": [{"literal":"-"}, "gRel$ebnf$2", {"literal":"->"}], "postprocess": ([, { type, value, labels },]) => ({ type: "graph-edge", direction: "outgoing", value: { type, value}, labels })},
    {"name": "gRel$ebnf$3", "symbols": ["gRelId"], "postprocess": id},
    {"name": "gRel$ebnf$3", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "gRel", "symbols": [{"literal":"<-"}, "gRel$ebnf$3", {"literal":"-"}], "postprocess": ([, { type, value, labels },]) => ({ type: "graph-edge", direction: "incoming", value: { type, value}, labels })},
    {"name": "graphPattern$ebnf$1", "symbols": []},
    {"name": "graphPattern$ebnf$1$subexpression$1", "symbols": ["gRel", "gNode"]},
    {"name": "graphPattern$ebnf$1", "symbols": ["graphPattern$ebnf$1", "graphPattern$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "graphPattern", "symbols": ["gNode", "gRel", "gNode", "graphPattern$ebnf$1"], "postprocess":  ([first, edge, second, rest]) => ({
        	type: "graph-pattern",
        	value: rest.reduce(
        		(pat, [e, n]) => ([ ...pat, { first: pat[pat.length -1].second, edge: e, second: n } ]), 
        		[{ first, second, edge }]
        	)
        }) 
        	},
    {"name": "string", "symbols": [(lexer.has("string") ? {type: "string"} : string)], "postprocess": ([{ value }]) => value.slice(1, value.length -1)},
    {"name": "number", "symbols": [(lexer.has("digits") ? {type: "digits"} : digits)], "postprocess": ([{ value }]) => +value},
    {"name": "number", "symbols": [(lexer.has("digits") ? {type: "digits"} : digits), (lexer.has("dot") ? {type: "dot"} : dot), (lexer.has("digits") ? {type: "digits"} : digits)], "postprocess": ([whole,, fraction]) => +(whole.value + "." + fraction.value)},
    {"name": "boolean", "symbols": [(lexer.has("true") ? {type: "true"} : true)], "postprocess": _ => true},
    {"name": "boolean", "symbols": [(lexer.has("false") ? {type: "false"} : false)], "postprocess": _ => false},
    {"name": "_$subexpression$1", "symbols": []},
    {"name": "_$subexpression$1", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws)]},
    {"name": "_$subexpression$1", "symbols": [(lexer.has("nl") ? {type: "nl"} : nl)]},
    {"name": "_", "symbols": ["_$subexpression$1"], "postprocess": _ => null},
    {"name": "__$subexpression$1", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws)]},
    {"name": "__$subexpression$1", "symbols": [(lexer.has("nl") ? {type: "nl"} : nl)]},
    {"name": "__", "symbols": ["__$subexpression$1"], "postprocess": _ => null}
]
  , ParserStart: "script"
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.grammar = grammar;
}
})();
